---
description: Trace and map code architecture for a specific feature or flow (terminal output)
---

# Task: Create a structured code trace map for terminal viewing

You are tracing: {{prompt}}

## CRITICAL: Accuracy Requirements

**You MUST only reference code that actually exists in the codebase:**
1. Before mentioning any function, command, file, or API endpoint, verify it exists
2. Use Grep/Glob to search for identifiers before referencing them
3. Read actual file contents rather than inferring behavior
4. If you're unsure whether something exists, search for it first
5. Never invent command names, function signatures, or API endpoints
6. Quote actual code when describing behavior

**Verification checklist before outputting:**
- [ ] All function names were found via Grep
- [ ] All file paths were confirmed via Glob or Read
- [ ] All command names were verified in actual source files
- [ ] No assumed behavior without reading the implementation

## Objectives

Create a comprehensive, structured map showing:
1. **Entry points**: Where the functionality begins (CLI commands, API endpoints, etc.)
2. **Execution flow**: Step-by-step progression through the codebase
3. **Key components**: Important functions, modules, and types involved
4. **Data transformations**: How data structures change through the flow
5. **Cross-cutting concerns**: Shared utilities, error handling, logging
6. **Architecture rationale**: Why the code is organized this way

## Process

1. **Discovery Phase**
   - Use Glob/Grep to find files matching the trace topic
   - Identify entry points (bin/, cmd/, api/ endpoints)
   - Map out major components involved

2. **Analysis Phase**
   - Read key files to understand flow
   - Identify function call chains
   - Note important data structures and transformations
   - Look for patterns (error handling, async/await, etc.)

3. **Synthesis Phase**
   - Group related code by responsibility
   - Create hierarchical view of execution flow
   - Annotate with "why" explanations
   - Add cross-references between components

## Output Format

Structure your trace as follows:

```
=== CODEMAP: [trace topic] ===

⚠️  Generated by Claude Code - verify critical details against source code

---

[ENTRY POINT(S)]
file:line - Description of where execution begins

[EXECUTION FLOW]
Numbered steps showing the main path through the code:
1. Phase Name
   file:line
   └─ function_name() - What it does and why

2. Next Phase
   file:line
   ├─ function_a() - Branch A
   └─ function_b() - Branch B

[KEY DATA STRUCTURES]
- StructName (file:line): Purpose and important fields
- EnumName (file:line): Variants and when each is used

[HELPER FUNCTIONS]
Grouped by responsibility:
- Validation: list of functions
- Serialization: list of functions
- Error handling: list of functions

[CROSS-CUTTING CONCERNS]
- Logging: Where and what is logged
- Error handling: Pattern used (Result, custom errors, etc.)
- Async: Which parts are async and why
- Testing: How this flow is tested

[ARCHITECTURE NOTES]
High-level explanation of design decisions:
- Why is X separate from Y?
- Why does this use pattern Z?
- What are the performance considerations?
```

Note: Do NOT include "Related Commits" or "Summary for Code Review" sections - they are redundant.

## Guidelines

- **File references**: Always use `file:line` format for easy navigation
- **Conciseness**: Keep descriptions to 1-2 sentences per item
- **Hierarchy**: Use indentation and tree symbols (├─ └─) to show relationships
- **Grouping**: Cluster related functions/files together
- **Context**: Explain "why" not just "what"
- **Completeness**: Cover the full flow from entry to exit
- **Practical**: Focus on code that actually executes, not every helper function

## ASCII Diagram Conventions

Use these for showing flow:
- Boxes: ┌─┐└─┘│ for components/steps
- Arrows: → ─> for flow direction
- Vertical flow: │ and ┬ ┴ for connections
- Tree structure: ├─ └─ for hierarchies
- Parallel flows: Show side-by-side with ─────>

## Depth Control

For complex traces:
- Start with high-level overview (3-5 major phases)
- Drill into each phase with specific functions
- Stop at helper functions (don't trace standard library calls)
- Note but don't expand trivial operations (logging, simple getters)

## Example References

Before starting, look at existing code in this repository to understand:
- Project structure and module organization
- Naming conventions for functions/types
- Common patterns (error handling, async, etc.)
- Where different responsibilities live

## Final Check Before Output

Before presenting your trace, verify:
1. Search for any command names you mentioned (e.g., `hurry cache restore`)
2. Confirm all function names exist in the files you reference
3. Verify all file:line references point to real code
4. Check that API endpoints match actual route definitions
5. If anything seems uncertain, search for it or mark it as "[unverified]"

Remember: It's better to say "I couldn't find X" than to hallucinate that X exists.

Begin your trace now.
