---
description: Trace code differences between base and current branch for code review (terminal output)
---

# Task: Create a structured diff trace map for terminal viewing

You are analyzing the differences between the base branch and the current branch to provide comprehensive code review context.

## CRITICAL: Accuracy Requirements

**You MUST only reference code that actually exists in the codebase:**
1. Before mentioning any function, command, file, or API endpoint, verify it exists
2. Use git diff and file reads to see what actually changed
3. Never invent commands, functions, or behavior that don't exist
4. If a change removed something, say "removed" - don't guess at a replacement
5. Quote actual code when describing changes
6. Verify line numbers match the current branch

**Verification checklist before outputting:**
- [ ] All mentioned commands exist (search in cmd/ directories)
- [ ] All function names were found via Grep or in diffs
- [ ] All file paths were confirmed via git diff or Glob
- [ ] Changes described match actual diff output
- [ ] No assumptions about behavior without reading implementation

## Objectives

Create a comparison-focused code map showing:
1. **Overview**: High-level summary of what changed and why
2. **Key architectural changes**: Major structural or design changes
3. **Execution flow changes**: How behavior differs between branches
4. **Execution flow diagrams**: ASCII diagrams showing old vs new data/logic flow
5. **Data structure changes**: New/modified types and fields
6. **API/signature changes**: Function signature changes and their impact
7. **Cross-cutting changes**: Patterns, error handling, logging, testing
8. **Review considerations**: Breaking changes, performance impact, migration notes

## Process

### Step 1: Identify Base Branch

1. Run `git status` to get current branch name
2. Run `git merge-base --fork-point main HEAD` to find merge base
   - If that fails, try `git merge-base main HEAD`
   - If main doesn't exist, try `master`
3. Store the merge base commit hash for comparisons

### Step 2: Discover Changed Files

1. Run `git diff --name-only <merge-base>...HEAD` to get list of changed files
2. Focus on code files (.rs, .ts, .py, etc.) - ignore generated files, lock files
3. For each changed file, run `git diff <merge-base>...HEAD -- <file>` to see changes

### Step 3: Analyze Changes

For each significant change:
- Read the current version of the file (on current branch)
- Identify what changed: new functions, modified logic, new types, etc.
- Understand the purpose: why was this changed?
- Trace dependencies: what other code does this affect?

### Step 4: Synthesize Review Context

Group changes into logical categories:
- **Structural changes**: Module organization, new files, deleted files
- **Behavioral changes**: Logic changes, algorithm improvements, bug fixes
- **Interface changes**: Public API modifications, breaking changes
- **Quality changes**: Tests, documentation, error handling improvements

## Output Format

Structure your trace diff as follows:

```
=== CODEMAP: <brief description> (base vs current-branch) ===

⚠️  Generated by Claude Code - verify critical details against source code and diffs

---

[OVERVIEW]
2-4 sentence summary of what this branch accomplishes and the approach taken.

[KEY ARCHITECTURAL CHANGE]

Before (base branch):
- How the code was structured
- What the limitations were

After (this branch):
- How it's now structured
- What improvements were made
- Why this approach was chosen

[CHANGED FILES]
List of modified files grouped by category:
- Core changes: Primary logic changes
- Supporting changes: Helpers, utilities
- Tests: New or modified tests
- Documentation: Comments, docs, examples

[EXECUTION FLOW CHANGES]

For each major flow that changed:

1. Feature/Flow Name
   file:line (old) → file:line (new)

   What changed:
   - Specific behavioral differences
   - New functionality added
   - Removed or deprecated behavior

   Impact:
   - What this enables/fixes
   - Any performance implications
   - Breaking changes or migrations needed

[EXECUTION FLOW DIAGRAMS]

For each logical pipeline that changed, show ASCII diagrams comparing old vs new:

Pipeline: <Name of the logical flow>

BEFORE (base branch):
┌─────────────────┐
│  Entry Point    │
└────────┬────────┘
         │
         v
┌─────────────────┐      ┌──────────────┐
│  Step 1         │─────>│  Data A      │
│  (function)     │      │  (state)     │
└────────┬────────┘      └──────────────┘
         │
         v
┌─────────────────┐
│  Step 2         │
│  (function)     │
└────────┬────────┘
         │
         v
┌─────────────────┐
│  Result         │
└─────────────────┘

AFTER (this branch):
┌─────────────────┐
│  Entry Point    │
└────────┬────────┘
         │
         v
┌─────────────────┐      ┌──────────────┐
│  Step 1         │─────>│  Data A      │
│  (modified fn)  │      │  (enhanced)  │
└────────┬────────┘      └──────┬───────┘
         │                      │
         │    ┌─────────────────┘
         │    │
         v    v
┌─────────────────┐      ┌──────────────┐
│  New Step 1.5   │─────>│  Data B      │
│  (new function) │      │  (new state) │
└────────┬────────┘      └──────────────┘
         │
         v
┌─────────────────┐
│  Step 2         │
│  (function)     │
└────────┬────────┘
         │
         v
┌─────────────────┐
│  Result         │
│  (enhanced)     │
└─────────────────┘

Key differences:
→ New Step 1.5 added to transform Data A into Data B
→ Data A enhanced with additional fields
→ Step 1 modified to populate new Data A fields
→ Result now includes information from Data B

Impact: This enables <what the change enables> while maintaining <what stays the same>.

[DATA STRUCTURE CHANGES]

For each modified type:

TypeName (file:line)
├─ Added fields:
│  └─ field_name: Type - Purpose and usage
├─ Modified fields:
│  └─ field_name: OldType → NewType - Why changed
└─ Removed fields:
   └─ field_name - Why removed, migration path

[API/SIGNATURE CHANGES]

Function signature changes (internal refactoring, not breaking unless public API):
- function_name() - Before: (params) → After: (new_params)
  - Why: Reason for change
  - Call sites: Where this function is called (if relevant)

Note: Internal function signature changes are NOT breaking changes unless they affect
public CLI commands or API routes. Focus on describing the refactoring motivation.

[CROSS-CUTTING CONCERNS]

Error Handling:
- New error types or error handling patterns
- Improved error messages or context

Logging/Observability:
- New tracing/logging added
- Changed log levels or instrumentation

Testing:
- New test coverage
- Changed test patterns
- Test utilities added/modified

Performance:
- Algorithmic improvements
- Concurrency changes
- Memory usage changes

Dependencies:
- Added dependencies and why
- Removed dependencies
- Updated dependencies and breaking changes

[REVIEW CONSIDERATIONS]

Breaking Changes (Public API Only):
IMPORTANT: Only report breaking changes to PUBLIC APIs that affect external users.
Do NOT report internal refactoring, function signature changes, or module reorganization.

Public API breaking changes include:
- CLI commands: Removed commands, changed command names, removed/changed flags
- CLI behavior: Same command now produces different output or side effects
- API routes: Removed endpoints, changed routes, changed request/response schemas
- API behavior: Same endpoint now behaves differently (different validation, side effects, etc.)

For each public breaking change:
- What: Describe the user-facing change
- Impact: How this affects external users/callers
- Migration: How users should adapt their usage

Examples:
- ✅ REPORT: "hurry cargo build --flag removed" (CLI change)
- ✅ REPORT: "POST /api/v1/cache now requires authentication" (API behavior change)
- ✅ REPORT: "hurry build now exits with code 2 instead of 1 on failure" (semantic change)
- ❌ DON'T REPORT: "collect_library_files() signature changed" (internal refactor)
- ❌ DON'T REPORT: "Workspace struct now has profile_dir field" (internal data structure)
- ❌ DON'T REPORT: "moved function from module A to module B" (internal organization)

Performance Impact:
- Expected performance changes (positive or negative)
- Benchmarks if available

Cache/State Compatibility:
- Does this change on-disk formats?
- Does this change API protocols?
- Do users need to reset/migrate state?

Testing Gaps:
- Areas that could use more test coverage
- Edge cases to consider

Future Work:
- TODO comments added
- Technical debt introduced/resolved
- Follow-up work needed

```

Note: Do NOT include "Related Commits" or "Summary for Code Review" sections - they are redundant with other sections.

## Guidelines

- **Focus on "why" not just "what"**: Explain motivations for changes
- **Highlight impact**: What does this enable? What breaks? What improves?
- **Be thorough**: Cover all significant changes, not just the main ones
- **Use diffs wisely**: Show before/after for clarity
- **Call out risks**: Breaking changes, performance concerns, migration needs
- **Link related changes**: Show how changes across files relate to each other
- **File references**: Always use `file:line` format for navigation
- **Visual clarity**: Use ASCII diagrams to make complex flow changes obvious

## ASCII Diagram Conventions

- Boxes: ┌─┐└─┘│ for components/steps
- Arrows: → ─> for flow direction
- Vertical flow: │ and ┬ ┴ for connections
- Parallel flows: Show side-by-side with ─────>
- Conditional: Use diamond shape or note "(if condition)"
- Data stores: ┌──────────┐ with "(state)" or "(data)"
- Functions: ┌──────────┐ with function name
- Loop: Show with curved arrows or note "(loop)"

Example conditional flow:
         │
         v
    ┌────────┐
    │ Check  │
    └───┬────┘
        │
    ┌───┴───┐
    │       │
    v       v
  [YES]   [NO]
    │       │
    v       v

Example parallel flow:
         │
    ┌────┴────┐
    │         │
    v         v
┌─────┐   ┌─────┐
│ Prl1│   │ Prl2│
└──┬──┘   └──┬──┘
   │         │
   └────┬────┘
        v

## Execution Flow Diagram Guidelines

### When to Create Diagrams

Create diagrams for:
- **Major algorithm changes**: When the core logic flow changes
- **Refactored pipelines**: When steps are reordered, added, or removed
- **Conditional logic changes**: When branching behavior changes
- **Data transformation flows**: When data passes through multiple stages
- **Parallel/concurrent changes**: When concurrency patterns change

### Diagram Quality

Keep diagrams:
- **Focused**: One logical pipeline per diagram
- **Clear**: Label all boxes and arrows
- **Concise**: Show key steps, not every function call
- **Comparative**: Always show BEFORE and AFTER side by side
- **Annotated**: Add "Key differences" list after each diagram pair

## Special Considerations

### Large Diffs
If the diff is very large (10+ files):
1. Start with high-level overview
2. Group related changes together
3. Focus on the most important changes first
4. Summarize bulk changes (e.g., "Updated 15 test files to use new assertion style")

### Refactoring vs New Features
Clearly distinguish:
- **Refactoring**: Structural changes, no behavior change
- **New features**: New functionality added
- **Bug fixes**: Corrected behavior
- **Breaking changes**: Incompatible modifications

### Configuration/Build Changes
Don't ignore:
- Makefile changes
- CI/CD changes
- Dependency updates
- Build script modifications

These often have important implications for deployment and development workflow.

## Final Check Before Output

Before presenting your trace diff, verify:

**Accuracy checks:**
1. Run git diff to confirm changes you're describing actually exist
2. Search for any command names you mentioned to ensure they exist
3. Verify function signatures match actual code on current branch
4. Check that all file:line references are accurate
5. Confirm API endpoints, routes, or CLI commands are real
6. If you see something in a diff but aren't sure what it does, read the file
7. Mark anything uncertain as "[unverified]" rather than guessing

**Breaking changes check:**
1. Trace through execution flow from public CLI commands to see if behavior changed
2. Check if any API routes were removed, renamed, or have different behavior
3. Verify if CLI commands were removed, renamed, or have different output/behavior
4. For internal changes: trace if they affect any public API contract semantics
5. Remove any "breaking change" mentions for internal refactoring

Remember:
- Git diffs show you exactly what changed - rely on them
- It's better to say "I couldn't verify X" than to hallucinate
- Users trust your output for code review - accuracy is critical
- Internal refactoring (even major) is NOT a breaking change

Begin your trace diff now.
