-- Schema file for Courier.
--
-- After making changes to this file, create a migration in ./migrations to
-- apply the new changes. Each migration should be sequentially ordered after
-- the previous one using its numeric prefix.
-- Organizations in the instance.
CREATE TABLE organization (
  id BIGSERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Each distinct actor in the application is an "account"; this could be humans
-- or it could be bots. In the case of bots, the "email" field is for where the
-- person/team owning the bot can be reached.
CREATE TABLE account (
  id BIGSERIAL PRIMARY KEY,
  organization_id BIGINT NOT NULL REFERENCES organization(id),
  email TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Keys for accounts to use to authenticate.
CREATE TABLE api_key (
  id BIGSERIAL PRIMARY KEY,
  account_id BIGINT NOT NULL REFERENCES account(id),
  name TEXT NOT NULL,
  hash BYTEA NOT NULL UNIQUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  accessed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  revoked_at TIMESTAMPTZ
);

-- Lists CAS keys known about by the database.
--
-- Since the CAS keys are actually on disk, technically there could be keys
-- that exist that are not in the database (or vice versa) but the ones in the
-- database are the only ones that the application knows exist.
CREATE TABLE cas_key (
  id BIGSERIAL PRIMARY KEY,
  content BYTEA NOT NULL UNIQUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Controls what organizations have access to a given CAS key.
--
-- We deduplicate CAS keys: if two organizations both save the same content,
-- we only actually store one copy of it (since they're keyed by content, they
-- are by defintion safe to deduplicate).
--
-- Organizations are given access after they upload the content themselves.
CREATE TABLE cas_access (
  organization_id BIGINT NOT NULL REFERENCES organization(id),
  cas_key_id BIGINT NOT NULL REFERENCES cas_key(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (organization_id, cas_key_id)
);

-- Cargo cache: stores SavedUnit instances as JSONB.
--
-- This table uses a JSONB-based approach for simplicity and flexibility:
-- - SavedUnit types are directly serialized to JSONB without decomposition
-- - cache_key is a stable hash of SavedUnitCacheKey (includes unit hash + future fields)
-- - No impedance mismatch: Rust types ARE the storage format
-- - Future-proof: Adding fields to SavedUnitCacheKey doesn't require schema changes
--
-- Access pattern is simple key-value:
-- - Save: INSERT complete SavedUnit by cache_key
-- - Restore: SELECT by cache_key and deserialize
--
-- File contents are stored in CAS (deduplicated), JSONB only stores metadata.
CREATE TABLE cargo_saved_unit (
  id BIGSERIAL PRIMARY KEY,
  organization_id BIGINT NOT NULL REFERENCES organization(id),
  -- The Cargo unit hash of the saved unit.
  --
  -- Note that it's possible for saved units within the same organization to
  -- have the same unit hash, because the unit hash is only uniquely determined
  -- by information known statically at the beginning of compilation.
  --
  -- For example, you could compile the same unit on two different machines, and
  -- get two different compiled units (in the sense that they produced two
  -- different sets of output files) that have the same unit hash. This could be
  -- because they have different embedded filepaths (e.g. for panic debugging),
  -- their build scripts used different files as inputs or produced different
  -- files as outputs, or they were linked against different native libraries
  -- (this list is non-exhaustive).
  unit_hash TEXT NOT NULL,
  -- The resolved architecture target triple of the unit. Note that this is
  -- subtly different from "the value of the `--target` flag", because it
  -- defaults to the host architecture when `--target` is unset.
  unit_resolved_target TEXT NOT NULL,
  -- If the unit was compiled for a Linux target that links against glibc (e.g.
  -- `x86_64-unknown-linux-gnu`), this field contains the version of the glibc
  -- version that the unit was compiled against. This prevents us from restoring
  -- units that were compiled for newer glibc versions onto machines with older
  -- glibc versions, where the unit would fail to link.
  --
  -- In particular, this impacts library crates that produce shared objects
  -- (e.g. `cdylib` or `proc-macro` kinds), build script programs, and some
  -- build script outputs (especially when generated by a build script program
  -- running a C compiler).
  --
  -- This could theoretically be a problem for other native libraries too, but
  -- glibc seems to be the only one commonly using symbol versioning that Rust
  -- projects dynamically link against without declaring a dependency in their
  -- build scripts.
  --
  -- For other compilation targets, this field is NULL.
  linux_glibc_version TEXT,
  -- Note that elements in this JSONB blob reference CAS keys.
  --
  -- TODO: Normalize this JSONB blob into tables? Or at least add a version
  -- field for schema upgrades.
  data JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(organization_id, unit_hash)
);

CREATE INDEX idx_cargo_saved_unit_org_key ON cargo_saved_unit(organization_id, unit_hash);
